<h2><a href="/?article=vulkan_triangle.txt">Hello, Triangle</a></h2>

<p>
They say a picture is worth a thousand words and I think the same is true in software, especially when being taught it.
Asking someone to write code that just produces text output in the console just doesn't have the same magic as drawing an image onto the screen.
Seeing colours and shapes appear is a powerful motivator and can inspire some amazing creativity too.
It is a shame then, that the barrier to entry for computer graphics is perceived as being so high with either extremely complex low level APIs or massive game engines to learn.
It can be overwhelming for someone starting out these days. 
</p>

<p>
It was simpler when I was first learning graphics, the engines that are so popular now either didn't exist or were not as freely available.
I don't recall anyone seriously suggesting starting their experimentation in the field with a game engine like they would today.
OpenGL was what we were taught and due to its age, being first introduced in 1992 before complex programmable pipelines existed, it offered a surprisingly gentle introduction into graphics.
You could use the old immediate mode, fixed function pipeline with glVertex, glColor etc along with hard coded light sources to get something functional very quickly and you could then gradually replace this older functionality as you learned it with the more modern equivalents.
This was a great strength of OpenGL for learning graphics but it also was a weakness that meant the API was littered with long obsolete functions and modern functionality was increasingly more difficult to add.
OpenGL is still supported however and I would wholeheartedly recommend that someone starting out, begin there. It's easy to learn and there are lots of great tutorials available.
</p>

<p>
However, I know you are not going to listen to me because OpenGL has not been updated since 2017 and as a result you are probably going to learn Vulkan.
Vulkan unfortunately lacks the beginner friendly on-ramp that OpenGL has. It has offloaded much of the setup that previously was performed internally by the gpu drivers to the programmer, allowing them much greater control and in theory better performance.
Once all this setup is complete, the actual day to day experience is not that different from OpenGL but the setup itself is daunting and I believe scares off most who attempt it, either pushing them towards using game engines or just not doing graphics at all.
This is sad.
</p>

<p>
There are some great tutorials available for Vulkan but I think many assume the reader is already quite experienced in APIs like OpenGL and as a result are too difficult for people just starting out.
When someone is learning a new language or platform for the first time, they tend to write a ubiquitous <i>Hello, World!</i> program like so:
</p>

<p class="code c-syntax">
#include &lt;iostream&gt;

int main() {
    std::cout << "Hello, World!\n";
    return 0;
};
</p>

<p>
But I haven't found many Hello Triangle equivalents for Vulkan that I think would be suitable for a beginner.
So I've tried to make my own which I am going to detail here.
</p>

<p class="note">
Before we begin, a quick warning. I didn't try to do things properly, merely as fast as possible to hopefully give others a simple starting point. This code will certainly not be performant or be doing everything correctly.
Also, even the simplest Vulkan is going to be quite verbose, you will get tired typing all this in but once set up, the jump from a triangle to a 3d world isn't as big as you might think.
</p>

<h3>Part 1 - The ingredients</h3>

<p>
I'm going to assume that you've installed the <a href="https://www.vulkan.org/">Vulkan SDK</a> and have an IDE with a C/C++ compiler ready to go. I also won't be explaining how to link all the various libraries together.
If you don't know how to do all this already, then maybe its not quite time to jump into computer graphics.
</p>

<p>
In addition to Vulkan and the standard library, we are also going to use four other libraries:<br/><br/>
    - <a href="https://github.com/glfw/glfw">GLFW3</a> - handles input and window creation in an OS agnostic way<br/>
    - <a href="https://github.com/charles-lunarg/vk-bootstrap">VkBootstrap</a> - removes several hundred lines of initial setup<br/>
    - <a href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">VMA (Vulkan Memory Allocator)</a> - makes it easier to create memory buffers for storing vertices etc on the GPU<br/>
    - <a href="https://github.com/g-truc/glm">GLM</a> - adds some helper data structures for matrices and vertices<br/><br/>

The code will be using some light C++ features, so you'll want to make sure you are using at least the C++ 20 standard which supports struct initializers.
</p>

<h3>Part 2 - The code</h3>

<p>
We add the standard libraries we are going to use:
</p>

<p class="code c-syntax">
#include &lt;fstream&gt; // this is for loading shaders (the code that runs on the gpu)
#include &lt;assert.h&gt; // this is for checking the results of Vulkan calls
#include &lt;vector&gt;
#include &lt;array&gt;
</p>

<p>
Then, we add the extra libraries and a little helper preprocessor macro:
</p>

<p class="code c-syntax">
#include &lt;glm/vec2.hpp&gt; // we just use the 2d vertex class in this code

// GLFW was originally made for OpenGL so this directive is required to make it support Vulkan
#define GLFW_INCLUDE_VULKAN
#include &lt;GLFW/glfw3.h&gt;

#include &lt;VkBootstrap.h&gt;

// These directives are required to make the Vulkan Memory Allocator correctly bind to the Vulkan implementation
#define VMA_STATIC_VULKAN_FUNCTIONS 0
#define VMA_DYNAMIC_VULKAN_FUNCTIONS 1
#define VMA_IMPLEMENTATION
#include &lt;vk_mem_alloc.h&gt;

// This will be used to wrap Vulkan calls to trigger an error if something has gone wrong, it'll be a lot harder to spot bugs without it
#define VK_CHECK(x) {VkResult err = x; assert(err == VK_SUCCESS);}
</p>

<p>
Before the main function, we define a small function to help load shader files:
</p>

<p class="code c-syntax">
std::vector&lt;char&gt; load_shader(std::string filename) {
    std::ifstream file(filename, std::ios::ate | std::ios::binary);
    assert (file.is_open());
    std::vector&lt;char&gt; buffer(file.tellg());
    file.seekg(0);
    file.read(buffer.data(), buffer.size());
    file.close();
    return buffer;
}
</p>

<p class="note">
The shader code will be shown after the application code has been finished.
</p>

<p>
Into the main function now, where we initialize GLFW3 and create the window we are going to render into:
</p>

<p class="code c-syntax">
int main() {
    glfwInit();
    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); // GLFW_NO_API as we aren't using any OpenGL functionality
    glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); // disable resizing so there is one less thing to worry about

    std::string app_name = "whatever name you want";
    unsigned int width = 800;
    unsigned int height = 600;
    GLFWwindow * window = glfwCreateWindow(width, height, app_name.c_str(), nullptr, nullptr);
</p>

<p class="note">
If you ran the code so far (and added <b>return 0;} to the end so it would compile) a blank window with the title <i>whatever name you want> would pop up and then suddenly disappear as the application exited.
</p>

<p>
We are about to get into the nasty and verbose boilerplate setup code but first we define all the variables our application is going to be using afterwards:
</p>

<p class="code c-syntax">
    // these are all VkBootstrap specific variables
    vkb::Instance instance;
    vkb::Device device;
    vkb::DispatchTable dispatch_table; // this contains functions pointers bound to the Vulkan implementation
    //the swapchain controls giving us an image to draw to, while rendering the last one we already drew to
    vkb::Swapchain swapchain;

    // These are VulkanMemoryAllocator specific variables - you'll see how they are used later
    VmaAllocator allocator;
    VmaAllocation vertex_buffer_allocation;
    
    // These are raw Vulkan variables
    VkQueue graphics_queue; // this is a handle to the part of the GPU that can take graphics instructions
    VkSurfaceKHR surface; // this is the part of the window created above where our rendered image will be going
    VkCommandPool command_pool; // this is what the command_buffer below is created from
    VkCommandBuffer command_buffer; // this is what we'll be giving draw commands to
    VkSemaphore swapchain_semaphore; // this is necessary to ensure its safe to grab an image to draw from
    VkPipelineLayout pipeline_layout; // we don't do much with this but we've got to have it
    VkPipeline pipeline; // the pipeline defines how vertices are handled, what shader programs are run etc
    VkBuffer vertex_buffer; // this will hold the triangle vertices
</p>

<p>
Here we go, the dreaded boilerplate (albeit reduced thanks the VkBootstrap and VMA). Vulkan likes to take structs as parameters to its API so there are going to be a lot of them.
</p>

<p>
We create the vulkan instance (you can have multiple instances talking to multiple graphics cards) and the link to the vulkan device (GPU) we will be using. VkBootstrap makes this reasonably simple:
</p>

<p class="code c-syntax">
    // Note: this section is wrapped in brackets to prevent all the temporary variables from hanging around
    { 
        vkb::InstanceBuilder builder;
        instance = builder.set_app_name(app_name.c_str())
            .request_validation_layers() // this is an optional feature that prints very useful debug messages
            .use_default_debug_messenger() // this tells the validation layer to use the standard output
            .require_api_version(1,3,0) // this is saying we want vulkan 1.3 (which is a little simpler to use)
            .build().value();

        vkb::PhysicalDeviceSelector selector{instance};
 
        glfwCreateWindowSurface(instance.instance, window, nullptr, &surface);

        // this is creating a description of what kind of device we want to use
        vkb::PhysicalDevice physical_device = selector
            .set_minimum_version(1, 3)
            .set_required_features_13(VkPhysicalDeviceVulkan13Features {
                .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES,
                .synchronization2 = true,
                // this removes the need for renderpasses, further simplifying setup
                .dynamicRendering = true
            })
            .set_required_features_12(VkPhysicalDeviceVulkan12Features {
                .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES,
                .descriptorIndexing = true,
                .bufferDeviceAddress = true
            })
            .set_surface(surface)
            .select()
            .value();

        // this will give us a handle to a device that meets the above criteria
        vkb::DeviceBuilder device_builder {physical_device};
        device = device_builder.build().value();

        // bind the vulkan api function pointers to the vulkan implementation
        dispatch_table = device.make_table();
</p>

<p>
At this point we have established a link to the GPU, next we have to create the means by which we can submit drawing commands to it:
</p>

<p class="code c-syntax">
        // we want the graphics queue, if we were doing compute work, we'd ask for the compute queue
        graphics_queue = device.get_queue(vkb::QueueType::graphics).value();
        VkCommandPoolCreateInfo command_pool_create_info {
            .sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
            .pNext = nullptr,
            // this means we'll be resetting the command buffer frequently
            .flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
            .queueFamilyIndex = device.get_queue_index(vkb::QueueType::graphics).value()
        };
        VK_CHECK(dispatch_table.fp_vkCreateCommandPool(device.device, &command_pool_create_info, nullptr, &command_pool));

        VkCommandBufferAllocateInfo command_buffer_allocate_info {
            .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
            .pNext = nullptr,
            .commandPool = command_pool,
            .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY, // there are secondary level buffers too but we don't need to worry about them
            .commandBufferCount = 1 // we are just creating 1 buffer
        };
        VK_CHECK(dispatch_table.fp_vkAllocateCommandBuffers(device.device, &command_buffer_allocate_info, &command_buffer));
</p>

<p>
We now can send drawing commands to the GPU but we haven't set up the graphics pipeline yet which we need to  or we won't be able to see anything, so next let's make the swapchain:
</p>

<p class="code c-syntax">
        // semaphores are used for synchronization to prevent us accessing resources when they aren't ready
        // this semaphore will be passed to the swapchain to tell us when it's safe to grab an image from it
        VkSemaphoreCreateInfo semaphore_create_info {
            .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO
        };
        VK_CHECK(dispatch_table.fp_vkCreateSemaphore(device.device, &semaphore_create_info, nullptr, &swapchain_semaphore));

        // the swapchain handles what image is currently being rendered, and what image is currently being drawn to
        vkb::SwapchainBuilder swapchain_builder {device, surface};
        swapchain = swapchain_builder
            .set_desired_format({.format = VK_FORMAT_B8G8R8A8_UNORM}) // the colour format we want
            // this mode means the swapchain will wait for the vertical blank before switching the images
            .set_desired_present_mode(VK_PRESENT_MODE_FIFO_KHR)
            .set_desired_extent(width, height)
            .add_image_usage_flags(VK_IMAGE_USAGE_TRANSFER_DST_BIT)
            .build().value();
</p>

<p>
Now here is the biggest single section, where we create the graphics pipeline and load the shaders:
</p>

<p class="code c-syntax">
        // the pipeline object needs a pipeline_layout object as a parameter  
        VkPipelineLayoutCreateInfo pipeline_layout_create_info {
            .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO
        };
        VK_CHECK(dispatch_table.fp_vkCreatePipelineLayout(device.device, &pipeline_layout_create_info, nullptr, &pipeline_layout));

        // the vertex binding description tells the shaders how vertex data is stored
        // the key value here is the stride which is saying that there is a vertex at 
        // every offset of sizeof(glm::vec2) in the vertex buffer
        // which we'll populate later
        VkVertexInputBindingDescription vertex_binding_description = {
            .binding = 0,
            .stride = sizeof(glm::vec2),
            .inputRate = VK_VERTEX_INPUT_RATE_VERTEX
        };

        // this is saying the data format of the vertex and where they start in the buffer
        VkVertexInputAttributeDescription vertex_attribute_description = {
            .location = 0,
            .binding = 0,
            // 2d vertices so two 32 bit channels should suffice
            .format = VK_FORMAT_R32G32_SFLOAT,
            .offset = 0
        };

        VkPipelineVertexInputStateCreateInfo vertex_input_state_create_info {
            .sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
            .vertexBindingDescriptionCount = 1,
            .pVertexBindingDescriptions = &vertex_binding_description,
            .vertexAttributeDescriptionCount = 1,
            .pVertexAttributeDescriptions = &vertex_attribute_description
        };

        VkPipelineInputAssemblyStateCreateInfo input_assembly_state_create_info {
            .sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
        };

        VkPipelineViewportStateCreateInfo viewport_state_create_info {
            .sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
            .viewportCount = 1,
            .scissorCount = 1
        };

        VkPipelineRasterizationStateCreateInfo rasterization_state_create_info {
            .sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
            .depthClampEnable = VK_FALSE,
            .rasterizerDiscardEnable = VK_FALSE,
            .polygonMode = VK_POLYGON_MODE_FILL,
            .depthBiasEnable = VK_FALSE,
            .lineWidth = 1.f
        };

        // we are using dynamic mode from vulkan 1.3 so we need to say what aspect need to be dynamic
        std::vector&lt;VkDynamicState&gt; dynamic_states = {
            VK_DYNAMIC_STATE_VIEWPORT,
            VK_DYNAMIC_STATE_SCISSOR,
            VK_DYNAMIC_STATE_CULL_MODE,
            VK_DYNAMIC_STATE_FRONT_FACE,
            VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY
        };

        VkPipelineDynamicStateCreateInfo dynamic_state_info {
            .sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
            .dynamicStateCount = static_cast&lt;uint32_t&gt;(dynamic_states.size()),
            .pDynamicStates = dynamic_states.data()
        };

        // finally, we load our shader programs
        auto vertex_shader_binary = load_shader("vertex.spv");
        auto frag_shader_binary = load_shader("fragment.spv");

        VkShaderModuleCreateInfo vertex_shader_module_create_info = {
            .sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
            .codeSize = vertex_shader_binary.size(),
            .pCode = reinterpret_cast&lt;const uint32_t*&gt;(vertex_shader_binary.data())
        };

        VkShaderModuleCreateInfo frag_shader_module_create_info = {
            .sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
            .codeSize = frag_shader_binary.size(),
            .pCode = reinterpret_cast&lt;const uint32_t*&gt;(frag_shader_binary.data())
        };

        VkShaderModule vertex_shader_module;
        VK_CHECK(dispatch_table.fp_vkCreateShaderModule(device.device, &vertex_shader_module_create_info, nullptr, &vertex_shader_module));

        VkShaderModule frag_shader_module;
        VK_CHECK(dispatch_table.fp_vkCreateShaderModule(device.device, &frag_shader_module_create_info, nullptr, &frag_shader_module));

        std::array&lt;VkPipelineShaderStageCreateInfo, 2&gt; shader_stages = {
            VkPipelineShaderStageCreateInfo {
                .sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
                .stage = VK_SHADER_STAGE_VERTEX_BIT,
                .module = vertex_shader_module,
                .pName = "main"
            },
            VkPipelineShaderStageCreateInfo {
                .sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
                .stage = VK_SHADER_STAGE_FRAGMENT_BIT,
                .module = frag_shader_module,
                .pName = "main"
            }
        };

        VkGraphicsPipelineCreateInfo graphics_pipeline_create_info = {
            .sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            .pNext = nullptr,
            .flags = VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT,
            .stageCount = static_cast&lt;uint32_t&gt;(shader_stages.size()), // vertex and fragment stages
            .pStages = shader_stages.data(),
            .pVertexInputState = &vertex_input_state_create_info,
            .pInputAssemblyState = &input_assembly_state_create_info,
            .pViewportState = &viewport_state_create_info,
            .pRasterizationState = &rasterization_state_create_info,
            .pDynamicState = &dynamic_state_info,
            .layout = pipeline_layout
        };
        VK_CHECK(dispatch_table.fp_vkCreateGraphicsPipelines(device.device, VK_NULL_HANDLE, 1, &graphics_pipeline_create_info, nullptr, &pipeline));

        // once bound to the pipeline, you can safely destroy the shader modules
        dispatch_table.fp_vkDestroyShaderModule(device.device, frag_shader_module, nullptr);
        dispatch_table.fp_vkDestroyShaderModule(device.device, vertex_shader_module, nullptr);
</p>

<p>
We now have the device, the command buffer and the graphics pipeline ready - the last part before we can start drawing is to create and populate the vertex buffer:
</p>

<p class="code c-syntax">
        // the vertices that make up the triangle you are going to see soon
        std::vector&lt;glm::vec2&gt; vertices = {
            glm::vec2(0.0f, -0.5f),
            glm::vec2(0.5f, 0.5f),
            glm::vec2(-0.5f, 0.5f)
        };

        VmaVulkanFunctions vulkan_functions
        {
            .vkGetInstanceProcAddr = instance.fp_vkGetInstanceProcAddr,
            .vkGetDeviceProcAddr = instance.fp_vkGetDeviceProcAddr
        };

        VmaAllocatorCreateInfo allocator_info {
            .flags = VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT,
            .physicalDevice = device.physical_device,
            .device = device.device,
            .pVulkanFunctions = &vulkan_functions,
            .instance = instance.instance
        };

        vmaCreateAllocator(&allocator_info, &allocator);

        VkBufferCreateInfo buffer_info = {
            .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
            .size = vertices.size() * sizeof(glm::vec2),
            .usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT
        };

        VmaAllocationCreateInfo vma_alloc_create_info {
            .usage = VMA_MEMORY_USAGE_CPU_TO_GPU
        };

        VK_CHECK(vmaCreateBuffer(allocator, &buffer_info, &vma_alloc_create_info, &vertex_buffer, &vertex_buffer_allocation, nullptr));

        // this is how you transfer data from the host (cpu) to the device (gpu)
        {
            void *data;
            vmaMapMemory(allocator, vertex_buffer_allocation, &data);
            memcpy(data, vertices.data(), vertices.size() * sizeof(glm::vec2));
            vmaUnmapMemory(allocator, vertex_buffer_allocation);
        }
    } // we are now leaving the scope brackets surrounding the infamous Vulkan boilerplate
</p>

<p>
Now the drawing code:
</p>

<p class="code c-syntax">
    std::vector&lt;VkImageView&gt; image_views = swapchain.get_image_views().value();

    while(glfwWindowShouldClose(window) == false) {
        // this is not best practice but it saves us creating more fences and semaphores to keep things simple
        // replace these with fences or semaphores when you start getting deeper into Vulkan
        VK_CHECK(dispatch_table.fp_vkDeviceWaitIdle(device.device));

        uint32_t swapchain_image_index;
        // 1000000000 is the number of nano seconds it'll wait to acquire the image
        VK_CHECK(dispatch_table.fp_vkAcquireNextImageKHR(device.device, swapchain.swapchain, 1000000000, swapchain_semaphore, VK_NULL_HANDLE, &swapchain_image_index));

        VK_CHECK(dispatch_table.fp_vkResetCommandBuffer(command_buffer, 0));

        VkCommandBufferBeginInfo command_buffer_begin_info {
            .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
            .pNext = nullptr,
            .flags = 0,
            .pInheritanceInfo = nullptr,
        };
        VK_CHECK(dispatch_table.fp_vkBeginCommandBuffer(command_buffer, &command_buffer_begin_info));

        VkRenderingAttachmentInfo color_attachment {
            .sType       = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO,
            .imageView   = image_views[swapchain_image_index],
            .imageLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
            .loadOp      = VK_ATTACHMENT_LOAD_OP_CLEAR,
            .storeOp     = VK_ATTACHMENT_STORE_OP_STORE,
            .clearValue  = VkClearValue {
                .color = VkClearColorValue {
                    .float32 = {0.0f, 0.0f, 0.0f, 1.0f}
                }
            }
        };

        VkRenderingInfo rendering_info {
            .sType = VK_STRUCTURE_TYPE_RENDERING_INFO,
            .renderArea = VkRect2D {
                .offset = {0,0},
                .extent = VkExtent2D {
                    .width = width,
                    .height = height
                },
            },
            .layerCount = 1,
            .colorAttachmentCount = 1,
            .pColorAttachments = &color_attachment
        };
        dispatch_table.fp_vkCmdBeginRendering(command_buffer, &rendering_info);

        dispatch_table.fp_vkCmdBindPipeline(command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline);

        VkViewport viewport {
            .x = 0,
            .y = 0,
            .width = static_cast&lt;float&gt;(width),
            .height = static_cast&lt;float&gt;(height),
            .minDepth = 0.f,
            .maxDepth = 1.f
        };
        dispatch_table.fp_vkCmdSetViewport(command_buffer, 0, 1, &viewport);

        VkRect2D scissor = {
            .extent = VkExtent2D {width, height}
        };

        dispatch_table.fp_vkCmdSetScissor(command_buffer, 0, 1, &scissor);
        dispatch_table.fp_vkCmdSetCullMode(command_buffer, VK_CULL_MODE_NONE);
        dispatch_table.fp_vkCmdSetFrontFace(command_buffer, VK_FRONT_FACE_CLOCKWISE);
        dispatch_table.fp_vkCmdSetPrimitiveTopology(command_buffer, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST);

        VkDeviceSize offset = 0;
        vkCmdBindVertexBuffers(command_buffer, 0, 1, &vertex_buffer, &offset);
        dispatch_table.fp_vkCmdDraw(command_buffer, 3, 1, 0, 0);

        dispatch_table.fp_vkCmdEndRendering(command_buffer);

        VK_CHECK(dispatch_table.fp_vkEndCommandBuffer(command_buffer));
        VkSubmitInfo submit_info = {
            .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
            .pNext = nullptr,
            .waitSemaphoreCount = 0,
            .pWaitSemaphores = nullptr,
            .pWaitDstStageMask = nullptr,
            .commandBufferCount = 1,
            .pCommandBuffers = &command_buffer,
            .signalSemaphoreCount = 0,
            .pSignalSemaphores = nullptr
        };
        VK_CHECK(dispatch_table.fp_vkQueueSubmit(graphics_queue, 1, &submit_info, VK_NULL_HANDLE));
        
        VkPresentInfoKHR present_info = {
            .sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
            .pNext = nullptr,
            .waitSemaphoreCount = 1,
            .pWaitSemaphores = &swapchain_semaphore,
            .swapchainCount = 1,
            .pSwapchains = &swapchain.swapchain,
            .pImageIndices = &swapchain_image_index
        };
        VK_CHECK(dispatch_table.fp_vkQueuePresentKHR(graphics_queue, &present_info));

        VK_CHECK(dispatch_table.fp_vkDeviceWaitIdle(device.device));

        glfwPollEvents();
    }
</p>

<p class="note">
At this point the program will be rendering a triangle (assuming the shaders were created).
</p>

<p>
The last part of the application code is just the cleanup:
</p>

<p class="code c-syntax">
    {
        // wait till the gpu is finished doing work before cleaning up
        VK_CHECK(dispatch_table.fp_vkDeviceWaitIdle(device.device));
        
        vmaDestroyBuffer(allocator, vertex_buffer, vertex_buffer_allocation);
        dispatch_table.fp_vkDestroyPipeline(device.device, pipeline, nullptr);
        dispatch_table.fp_vkDestroyPipelineLayout(device.device, pipeline_layout, nullptr);
        dispatch_table.fp_vkDestroyCommandPool(device.device, command_pool, nullptr);
        dispatch_table.fp_vkDestroySemaphore(device.device, swapchain_semaphore, nullptr);
        for (auto& image_view : image_views) {
            dispatch_table.fp_vkDestroyImageView(device.device, image_view, nullptr);
        }
        vkb::destroy_swapchain(swapchain);
        vmaDestroyAllocator(allocator);
        vkb::destroy_device(device);
        vkb::destroy_surface(instance, surface);
        vkb::destroy_instance(instance);
    }

    glfwDestroyWindow(window);
    glfwTerminate();
    return 0;
}
</p>

<p>
Before I forget you need a vertex shader - let's call it basic.vert:
</p>

<p class="code c-syntax">
#version 450

layout(location = 0) in vec2 position;

void main() {
    gl_Position = vec4(position, 0.0, 1.0);
}
</p>

<p>
and a fragment shader - let's call it basic.frag:
</p>

<p class="code c-syntax">
#version 450

layout(location = 0) out vec4 outColor;

void main() {
    outColor = vec4(1.0, 0.0, 0.0, 1.0);
}
</p>

<p>
You need to compile these using the <b>glslc</b> compiler included with the VulkanSDK like so:
</p>

<p class="code c-syntax">
glslc basic.vert -o vertex.spv
glslc basic.frag -o fragment.spv</p>

<p>
and make sure to place these .spv files in the same directory as the executable.
</p>

<h3>Part 3 - The Result</h3>

<p>After all that work you should see the following:</p>

<img src="content/images/vulkan/red_triangle.png" alt="the output of our vulkan hello, triangle application"  width="500px" />