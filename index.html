<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8"/>
        <title>timcostigan.com</title>
        <link rel="stylesheet" href="styles.css" />
    </head>
    <body>
        <div id="header">
            <a class="title" href="/">
                timcostigan.com
            </a>
            <br/>
            <a class="external_link" href="https://github.com/timlump">github</a>
        </div>
        <table id="page_nav">
        </table>
        <script>
            function apply_syntax_highlighting(code_element, highlight_data) {
                content = code_element.innerHTML;

                // if it starts with a newline, remove it, this allows the code to start on a newline when editing it
                // but since we are preserving whitespace it means there isn't an empty line at the start
                content = content.replace(/^\n/,'');

                if (code_element.classList.contains("c-syntax")) {
                    // strings - needs to be done first are it will start matching the tags being added
                    content = content.replace(/"([^"]*)"/g, m => `<i class="string">${m}</i>`)

                    // comments
                    content = content.replace(/\/\/.*$/gm, m => `<i class='comment'>${m}</i>`);
                    
                    // preprocessor
                    content = content.replace(/#include|#define|#version|#pragma/g, m => `<b class="directive">${m}</b>`);
                    
                    // types
                    content = content.replace(/std::vector&lt;.*?&gt;/g, m => `<b class="variable">${m}</b>`);
                    content = content.replace(/std::array&lt;.*?&gt;/g, m => `<b class="variable">${m}</b>`);

                    if (highlight_data["c_syntax"]["types"].length > 0) {
                        // matches if in list and not touching other alphanumeric characters
                        const types_regex = new RegExp(`\\b(?:${highlight_data["c_syntax"]["types"].map(RegExp.escape).join('|')})\\b`, 'g');
                        content = content.replace(types_regex, m => `<b class="variable">${m}</b>`);
                    }

                    // constants
                    if (highlight_data["c_syntax"]["constants"].length > 0) {
                        // matches if in list and not touching other alphanumeric characters
                        const constants_regex = new RegExp(`\\b(?:${highlight_data["c_syntax"]["constants"].map(RegExp.escape).join('|')})\\b`, 'g');
                        content = content.replace(constants_regex, m => `<b class="constant">${m}</b>`);
                    }
                }

                code_element.innerHTML = content;
            }

            function load_article(name) {
                let filename = `content/${name}`;

                const new_article = document.createElement("div");
                new_article.className = 'article';
                new_article.id = filename;
                document.body.appendChild(new_article);

                fetch(filename)
                    .then(response => response.text())
                    .then((data) => {
                        let element = document.getElementById(filename);
                        element.innerHTML = data;

                        // need to load the syntax highlighting json to know what to highlight
                        fetch(`highlight_data.json`)
                            .then(response => response.json())
                            .then((type_data) => {
                                let code_elements = element.getElementsByClassName("code");
                                for (let i = 0; i < code_elements.length; i++) {
                                    apply_syntax_highlighting(code_elements[i], type_data);
                                }
                            })
                    });
            }

            let params = new URLSearchParams(window.location.search);

            if (params.has('article')) {
                load_article(params.get('article'));
            }
            else {
                const articles_per_page = 2;
                let current_page = 0;
                if (params.has('page')) {
                    current_page = params.get('page');
                }

                fetch('content/index.txt')
                .then(response => response.text())
                .then((data) => {
                    let lines = data.split('\n');

                    let num_pages = lines.length / articles_per_page;
                    if (num_pages > 1) {
                        let table = document.getElementById('page_nav');
                        let row = table.insertRow();
                        let cell = row.insertCell();
                        let text = document.createTextNode("Page: ");
                        cell.appendChild(text);
                        for (let idx = 0; idx < num_pages; idx++) {
                            let cell = row.insertCell();
                            let text = document.createTextNode(`${idx+1}`);
                            if (idx == current_page) {
                                cell.appendChild(text);
                            }
                            else {
                                let link = document.createElement('a');
                                link.href = `/?page=${idx}`;
                                link.title = `${idx+1}`;
                                link.appendChild(text);
                                cell.appendChild(link)
                            }
                        }
                    }

                    for(let idx = 0; idx < lines.length; idx++) {
                        let start_idx = current_page*articles_per_page;
                        let end_idx = start_idx + articles_per_page;
                        if (idx >= start_idx && idx < end_idx)
                        {
                            load_article(lines[idx]);
                        }
                    }
                });
            }
        </script>
    </body>
</html>